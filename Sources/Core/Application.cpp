#include "../../Headers/Core/Application.hpp"

std::unique_ptr<Application> Application::instance = std::unique_ptr<Application>(nullptr);

/**
* Constructor of the class Application.
* The constructor add all the commands of MakeLoader in the application.
* It also set the instance of the application the first time.
* @author Matrax
* @version 1.0
*/
Application::Application() : m_commands(std::vector<std::shared_ptr<Command>>()),
														 m_loaderfile(std::make_unique<LoaderFile>()),
														 m_makefile(std::make_unique<MakeFile>())
{
	if(Application::instance.get() != nullptr)
		throw std::runtime_error("Can't reinstantiate the application !");

	this->m_commands.push_back(std::make_shared<CreateCommand>());
	this->m_commands.push_back(std::make_shared<BuildCommand>());
	this->m_commands.push_back(std::make_shared<InfoCommand>());
	Application::instance.reset(this);
}

/**
* Destructor of the class Application.
* It release the instance of the application.
* @author Matrax
* @version 1.0
*/
Application::~Application()
{
	Application::instance.release();
}

/**
* This static function return the instance of the application.
* @return Application& The instance of the application.
* @author Matrax
* @version 1.0
*/
Application & Application::getInstance()
{
	if(Application::instance.get() == nullptr)
		throw std::runtime_error("No Application instance !");

	return *(Application::instance.get());
}

/**
* This function show in the console all the infos about MakeLoader.
* @author Matrax
* @version 1.0
*/
void Application::infos()
{
	std::cout << "\nMakeLoader Copyright (C) 2021 Alexandre Pierret" << std::endl;
	std::cout << "This program comes with ABSOLUTELY NO WARRANTY;" << std::endl;
	std::cout << "This is free software, and you are welcome to redistribute it" << std::endl;
	std::cout << "[MakeLoader] Version 1.0" << std::endl;
	std::cout << "[MakeLoader] More informations at https://github.com/Matrax/MakeLoader\n" << std::endl;
	std::cout << "Commands:" << std::endl;

	std::vector<std::shared_ptr<Command>> commands = Application::getInstance().getCommands();

	if(commands.empty() == true)
		throw std::runtime_error("No commands are loaded !");

	for(std::vector<std::shared_ptr<Command>>::iterator command = commands.begin(); command != commands.end(); command++)
	{
		std::cout << "\t" << command->get()->getName() << ": " << command->get()->getDescription() << std::endl;
	}

	std::cout << "\n";
}

/**
* This method start the application by running the command given in the console parameters.
* @param const int & argc The number of arguments
* @param char*[] argv The array of string parameters.
* @author Matrax
* @version 1.0
*/
void Application::start(const int & argc, char * argv[])
{
	if(argv == nullptr || argc <= 1)
		throw std::runtime_error("You need to put an argument (type ./makeloader info) !");

	if(this->m_commands.empty() == true)
		throw std::runtime_error("There are no commands loaded !");

	for(std::vector<std::shared_ptr<Command>>::iterator command = this->m_commands.begin(); command != this->m_commands.end(); command++)
	{
		if(command->get()->getName() == argv[1])
		{
			command->get()->execute();
			break;
		}
	}
}

/**
* This method return the list of commands in the application.
* @return std::vector<std::shared_ptr<Command>> the list of commands in the application.
* @author Matrax
* @version 1.0
*/
std::vector<std::shared_ptr<Command>> & Application::getCommands()
{
	return this->m_commands;
}

/**
* This method return the makefile generated by MakeLoader.
* @return MakeFile& the makefile generated by MakeLoader.
* @author Matrax
* @version 1.0
*/
MakeFile & Application::getMakefile()
{
	return *(this->m_makefile.get());
}

/**
* This method return the makeloader file used by MakeLoader.
* @return MakeFile& The makeloader file used by MakeLoader.
* @author Matrax
* @version 1.0
*/
LoaderFile & Application::getLoaderfile()
{
	return *(this->m_loaderfile.get());
}
