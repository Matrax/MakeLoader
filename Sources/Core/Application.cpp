#include "../../Headers/Core/Application.hpp"

std::unique_ptr<Application> Application::instance = std::unique_ptr<Application>(nullptr);

/**
* Constructor of the class Application.
* The constructor add all the commands of MakeLoader in the application.
* It also set the instance of the application the first time.
* @author Matrax
* @version 1.0
*/
Application::Application() : 
	m_commands(std::vector<std::shared_ptr<Command>>()), 
	m_loaderfile(std::make_unique<LoaderFile>()),
	m_makefile(std::make_unique<MakeFile>())
{
	if(Application::instance.get() == nullptr)
	{
		this->m_commands.push_back(std::make_shared<CreateCommand>());
		this->m_commands.push_back(std::make_shared<BuildCommand>());
		this->m_commands.push_back(std::make_shared<MakeCommand>());
		this->m_commands.push_back(std::make_shared<InfoCommand>());
		Application::instance.reset(this);
	} else {
		std::cout << "Can't reinstantiate the application !" << std::endl;
	}
}

/**
* Destructor of the class Application.
* It release the instance of the application.
* @author Matrax
* @version 1.0
*/
Application::~Application() 
{
	Application::instance.release();
}

/**
* This static function return the instance of the application.
* @return Application* The instance of the application.
* @author Matrax
* @version 1.0
*/
Application * Application::getInstance()
{
	return Application::instance.get();
}

/**
* This method start the application by running the command given in the console parameters.
* @param const int & argc The number of arguments
* @param char*[] argv The array of string parameters.
* @author Matrax
* @version 1.0
*/
void Application::start(const int & argc, char * argv[])
{
	if(argv == nullptr || argc <= 1) 
	{
		std::cout << "\n[MakeLoader] You need to put an argument !" << std::endl;
		std::cout << "[MakeLoader] type: makeloader info\n" << std::endl;
		return;
	}

	for(std::vector<std::shared_ptr<Command>>::iterator command = this->m_commands.begin(); command != this->m_commands.end(); command++)
	{
		if(command->get()->getName() == argv[1])
		{
			command->get()->execute();
			break;
		}
	}
}

/**
* This method return the list of commands in the application.
* @return std::vector<std::shared_ptr<Command>> the list of commands in the application.
* @author Matrax
* @version 1.0
*/
std::vector<std::shared_ptr<Command>> & Application::getCommands()
{
	return this->m_commands;
}

/**
* This method return the makefile generated by MakeLoader.
* @return MakeFile* the makefile generated by MakeLoader.
* @author Matrax
* @version 1.0
*/
MakeFile * Application::getMakefile()
{
	return this->m_makefile.get();
}

/**
* This method return the makeloader file used by MakeLoader.
* @return MakeFile* the makeloader file used by MakeLoaderthe.
* @author Matrax
* @version 1.0
*/
LoaderFile * Application::getLoaderfile()
{
	return this->m_loaderfile.get();
}